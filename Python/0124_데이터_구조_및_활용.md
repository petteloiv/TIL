## Python. 데이터 구조 및 활용 



### 1. 문자열 

- 문자들의 나열 
  - 모든 문자는 str 타입
- 문자열은 작은 따옴표, 큰 따옴표 활용하여 표기
- immutable하다! 

#### 1-1. 문자열 조회/탐색 및 검증 메소드 

![image-20220124133814056](0124_데이터_구조_및_활용.assets/image-20220124133814056.png)

- `is어쩌고()` 가 있다면 결과로 boolean값 반환!
- `.find(x)` 
  - x의 **첫번째 위치**를 반환
  - 없으면 -1 반환 
- `.index(x)`
  - x의 첫번째 위치를 반환
  - 없으면 ValueError 발생
- `istitle()` 
  - 공백 기준 첫 글자 대문자 표기 여부 

#### 1-2. 문자열 변경 메소드 

![image-20220124134521465](0124_데이터_구조_및_활용.assets/image-20220124134521465.png)

- 문자열은 immutable하지만, 원본 변경이 아니라 반환할 때 변경해서 반환한다.
- `.replace(old, new[,count])` 
  - 바꿀 대상 글자를 새로운 글자로 바꿔서 반환
  - count는 선택 .. 지정하면 해당 개수만큼만 시행 
- `.strip([chars])`
  - 많이 활용하게 됨!
  - 양쪽을 제거 / 왼쪽제거(lstrip) / 오른쪽제거(rstrip)
- `.split(sep=None, maxsplit=-1)`
  - 문자열을 특정한 단위로 나눠 **리스트로 반환**
    - sep이 None이거나 지정되지 않으면 연속된 공백문자를 단일 공백문자로 간주하고, 선행/후행 공백은 빈 문자열에 포함시키지 않음
    - maxsplit = -1 인 경우에는 제한이 없음
- `'separator'.join([iterable])` 
  - 반복가능한 컨테이너 요소들을 separator(구분자)로 합쳐 문자열 반환 
  - **iterable에 문자열 아닌 값 있으면 TypeError** 발생
    - 리스트 안의 값이 int이면 불가! 
    - str로 형변환 해서 사용하는식..



### 2. 리스트

- 순서를 가지는 0개 이상의 객체를 참조하는 자료형 
  - 생성된 이후 내용 변경 가능 => 가변자료형
  - 유연성 때문에 파이썬에서 가장 흔히 사용 

#### 2-1. 리스트 메소드

- 리스트의 요소를 변경시키는 것이 있다. 
- mutable하기 때문!

![image-20220124140355163](0124_데이터_구조_및_활용.assets/image-20220124140355163.png)

##### 추가 메소드

- `.append(x)` 
  - 가장 많이 사용
  - 리스트 마지막에 값 추가
- `.extend(iterable)` 
  - 리스트에 iterable 항목 추가
  - iterable이 리스트 형태여야한다! 
    - 문자열로 넣으면 알파벳으로 분해돼서 들어감.. 
- `.insert(i, x)` 
  - 정해진 위치 i에 값을 추가함
  - i가 리스트 길이보다 큰 경우 맨 마지막

##### 제거 메소드 

- `.remove(x)`
  - 리스트에서 **값이 x**인 것 삭제 
- `.pop()`
  - 맨 마지막에 있는 값 삭제
- `.pop(i)` 
  - 정해진 **위치 i**에 있는 값 삭제하고 항목 반환
- `.clear()`
  - 모든 항목 삭제 

##### 탐색 및 정렬 메소드 

- `.index(x)` 
  - x값을 찾아 해당 index 값을 반환
  - 값으로 인덱스 찾기....
- `.count(x)` 
  - 원하는 값의 개수 반환 
- `.sort()` 
  - 원본 리스트 정렬된 것으로 변경. **None 반환**
  - sorted() 함수랑 다름!
    - sorted는 정렬된 리스트 반환.. 원본 변경 X
- `.reverse()`
  - 원본 자체의 순서를 뒤집는다. (정렬 X)



### 3. 튜플

- 순서를 가지는 0개 이상의 객체를 참조하는 자료형
  - 생성 후 담고있는 객체 변경 불가! **불변 자료형** 
- 변경할 수 없기 때문에 값에 영향을 미치지 않은 메소드만을 지원
  - 리스트 메소드 중 변경하는것 제외하고 대부분 동일



### 순서가 없는 데이터 구조

### 4. 셋(Set)

-  순서 없이 0개 이상의 해시 가능한 객체를 참조하는 자료형
- 담고있는 객체를 삽입 변경, 삭제 가능 => **가변자료형**
- 수학 집합과 동일 구조
  - 집합 연산 가능
  - 중복 값 존재 X 

#### 4-1. 셋 메소드

![image-20220124143707246](0124_데이터_구조_및_활용.assets/image-20220124143707246.png)

- `.add(elem)`

  - 셋에 값을 추가! 

- `.update(*others)` 

  - 여러 값 추가 -> 중복된 값은 삭제됨

- `.remove(elem)`

  - 셋에서 삭제, 값이 없으면 KeyError

- `.discard(elem)`

  - 셋에서 삭제. 없어도 에러 발생 안함! 

  

### 5. 딕셔너리

- 순서 없이 키-값 쌍으로 이뤄진 객체 참조! 
- 딕셔너리 키 == 해시가능한 불변 자료형
- 각 키의 값(밸류) == 어떤 형태든 관계 없음

#### 5-1. 딕셔너리 메소드

![image-20220124144257447](0124_데이터_구조_및_활용.assets/image-20220124144257447.png)

- 중복불가능하고 고유 키가 존재해서 .append 등 없음
- 키로 접근하기 때문에 .index도 없음 
- `.get(key[,default])`
  - key 통해 value 가져옴
  - 키에러 발생 X None 반환 
- `.pop(key[,default])`
  - key가 딕셔너리에 있으면 제거하고 해당 값을 반환 

- `.update(키=밸류)` 
  - 값을 제공하는 key, value로 덮어쓴다.



### 얕은 복사와 깊은 복사 

#### 얕은 복사

#### 1-1. 할당

- 대입연산자 (=)
- 해당 객체에 대한 객체 참조를 복사 
- copy_list와 original_list은 같은 것을 바라보고 있당 ... 
- 해당 주소의 일부 값 변경하며 이를 참조하는 모든 변수에 영향

```python
# 객체 참조 복사 (같은 값,,, )
copy+list = original_list

# 연산된 결과 복사 (다른주소)
copy_list = list(original_list)
copy_list = original_list[:]
```



#### 깊은 복사

```python
import copy
a = [1, 2, ['a', 'b']]
b = copy.deepcopy(a)

# 값은 같지만 참조는 다르게 하고 싶을 때! 
```

 
