## 알고리즘_ 배열1

슈도코드 짜고 **읽을 줄** 알아야한다!!!!! 

[TOC]



### 1. 알고리즘 개요

---

##### 알고리즘

유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
컴퓨터가 어떤 일을 수행하기 위한 단계적 방법



##### 컴퓨터 분야에서 알고리즘을 표현하는 방법

1. 의사코드(슈도코드, Pseudocode)
2. 순서도



##### 무엇이 좋은 알고리즘인가?

1. **정확성** : 얼마나 정확하게 동작하는가
2. 작업량 : 얼마나 적은 연산으로 원하는 결과 얻어내는가
3. 메모리 사용량 : 얼마나 적은 메모리 사용하는가
4. 단순성 : 얼마나 단순한가
5. 최적성 : 더 이상 개선할 여지없이 최적화되었는가



##### 알고리즘의 성능 측정 

- 알고리즘의 성능 분석 필요
  - 성능 분석의 기준 : 알고리즘의 작업량
- 시간복잡도 (Time Complexity) - 알고리즘의 작업량 표현
  - 실제 걸리는 시간 측정
  - 실행되는 명령문 개수 계산
  - **빅-오 표기법**
    - 시간 복잡도 함수 중에서 가장 큰 영향력 주는 n에 대한 항만을 표시



### 2. 배열(List)

---

#### 1. 배열 개요

- 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
- 리스트..

##### 배열의 필요성

- 여러 개 변수가 필요할 때, 일일이 다른 변수명 이용해 접근하는 것은 매우 비효율적
- 하나의 선언 통해서 둘 이상의 변수 선언 가능
- 다수의 변수로는 하기 힘든 작업 쉽게 할 수 있다. 



#### 2. 1차열 배열의 선언 

- 파이썬 리스트 생성 방법과 같다... 

```python
arr = list()
arr = []
arr = [1, 2, 3]
arr = [0]*10 # 크기 미리 정해놓고 만드는게 필요할 때 있음! 
```



### 3. 정렬

---

#### 1. 정렬 개요

- 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순), 혹은 크 반대의 순서대로(내림차순) 재배열 하는 것 
- 키
  - 자료를 정렬하는 기준이 되는 특정 값

##### 정렬 방식의 종류

- **버블** 정렬
- **카운팅** 정렬
- 선택 정렬
- 퀵 정렬
- 삽입 정렬
- 병합 정렬



#### 2. 버블 정렬

- 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식 
- 정렬 과정
  - 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동
  - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬 (오름차순)
  - 교환하며 자리 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고해서 버블 정렬 ....
- 시간 복잡도
  - O(n2) / 막 효율적인 건 아니다.. 오래걸리네 ? 정도



#### 3. 카운팅 정렬 (카운트 배열)

- 항목들의 순서 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘 (뭔소리야)
- 나에게 주어진 정수의 **개수를 세는 방법**
- 자료값들이 **양의 정수가 적당한 범위 안에 있는 경우**에 유용
- 시간 복잡도
  - O(n+k) : n은 리스트 길이, k는 정수의 최대값 (보통 백만개 이하)

**정렬 과정**

- 정수 k개 주어지면 리스트 길이 = k+1
  - 원래 리스트 data
  - 개수 리스트 counts 
- 각 정수 나타난 횟수 리스트 인덱스에 맞게 저장
- 앞에서부터 숫자 누적으로 count 원소 조정
  - n = n-1 + n
  - counts[i] += counts[i-1]
- 정렬 결과 저장할 배열 생성
  - temp => 원래 리스트 data와  같은 크기
- data 리스트 맨 뒤 값부터 저장..
  - data[-i] 값
  - counts[data[-i]] -1 
  - temp[counts[data[-i]]-1] 에 data[-i] 값 저장
- Temp 업데이트 완료하고 정렬 작업 종료



### 해결법들

#### 1. 완전검색 

- 가능한 모든 경우의 수를 나열해보고 확인하는 기법
- 모든 경우 수 테스트 한 후, 최종 해법 도출
- 경우의 수가 상대적으로 작을 때 유용!
  - 수행 속도 매우 느리지만... 해답 못찾을 확률 거의 없음
- 완전 검색으로 접근해 해답 도출 -> 성능 개선 위해 다른 알고리즘 사용하고 해답 확인하는 것이 바람직! 



#### 2. 순열 (Permutation)

- 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
  - n개 중 r개 택하는 순열 => nPr (경우의 수)
    - n * (n-1) * (n-2) * ... * (n-r+1)



#### 3. 탐욕 (Greedy) 알고리즘

- 최적해를 구하는데 사용되는 근시안적인 방법
- 여러 경우 중 하나 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택하면서 진행 => 최종 해답
- **머릿속에 떠오르는 생각을 검증 없이 바로 구현**

---

- 동작 과정
  1. 해 선택 : 현재 상태에서 부분 문제의 최적 해 구한 뒤, 부분해집합에 추가
  2. 실행 가능성 검사 : 새로운 부분해 집합 => 실행 가능한지, 문제 제약 조건 위반 안하는지!
  3. 해 검사: 새로운 부분해 집합 => 문제의 해가 되는가? 아직 완성되지 않았다면 1번부터 다시 시작,,,