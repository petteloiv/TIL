## Stack 1 

 

### 1. 데이터와 자료구조 (data structure)

- 데이터(Data)
  - 경험이나 관찰로부터 얻어진 **조직화된 정보**의 모음
  - 과거에는 프로그램이 아닌 것을 데이터라고 했으나 ... 최근에는 프로그램도 데이터의 일종이라고 생각하게 됨.
- 자료구조
  - 데이터를 효율적으로 저장하고 관리하기 위한 방법 

#### 1. 데이터의 저장

- 스토리지 : 데이터가 **영구히** 저장되는 곳 (비휘발성)
  - HDD, SSD, USB, CD ...
  - 용량이 크지만 속도가 느림 
  - 당장 필요한 데이터가 아닌 데이터 
  - 차근차근 순서대로 데이터 쌓아나간다.



- 메모리 : 데이터가 **임시적으로** 저장되는 곳 (휘발성)
  - 용량 작지면 속도가 매우 빠름! 
  - 당장 필요한 데이터가 위치 (모든 내용 처리는 힘들다.)
  - 메모리를 효율적으로 사용하자! 
  - 저장하기 : 메모리에 저장된 내용을 스토리지로 옮기는 것
  - 메모리의 구성 
    - 데이터가 저장되는 위치는 랜덤 (무작위 저장)
    - RAM (Random Access Memory) 이 램이... 그 램이었어...! 
    - 각 칸(저장한 랜덤위치)마다 주소값이 지정되어 있음.

#### 2. 데이터 타입 (Data Type)

| Data Type |
| --------- |
| int       |
| float     |
| char      |
| string    |



#### 3. 자료 구조

1. 선형 자료구조
   -  list, stack, queue ...
2. 비선형 자료구조 



- 데이터에 맞는 자료구조를 잘 파악하면
  - 데이터 표현하기 쉽고
  - 데이터 이해하기 쉽고
  - 데이터 활용하기 쉽다!



##### 추상 데이터 타입 (Abstract Data Type)

**구조화된 데이터**를 필요한 **연산**과 함께 묶어서 표현하는 방법

Abstract Data Type = Structured Data + Operation



- 데이터 구조 추상화하는 법
  - 개별적인 특징을 지우고
  - 데이터 구조의 특징을 도출 (ex. 순서가 있는 나열된 구조)
  - 필요한 연산을 정의 (ex. 추가, 삭제, ㅜ정)



### 2. 스택 Stack

스택은 물건을 쌓아 올린 듯, **자료를 쌓아 올린 형태**의 자료구조

- 예시 (함수 콜 스택)
  -  factorial 같은 경우에는 factorial (n) 구하려면 factorial(1) 부터 순차적으로 실행해야한다.

- stackoverflow : 전 세계 개발자들이 개발 관련해서 검색할 때 많이 이용하는 곳
  - 가장 최신의 정보가 가장 먼저 검색된다는 의미 

- 특징

1) 가장 마지막에 들어간 것이, 가장 처음에 나온다. (**후입선출**, LIFO)
2) 가장 위에서만 데이터의 삽입 & 삭제가 일어난다.

---

3. 스택에 저장된 자료는 선형 구조를 갖는다.
   - 선형구조 : 자료 간의 관계가 1:1의 관계
   - 비선형구조 : 자료 간의 관계가 1:N의 관계 (ex. 트리) (얽히고 섥힌 관계)
4. 스택에 자료를 삽입하거나 스택에서 자료를 꺼낼 수 있다. 



- 생활 속 예시
  - 뒤로가기 버튼 ... (브라우저 히스토리)



### 3. ADT로 표현한 스택 

1. 스택의 연산 (Operations of stack)

| 연산        | 설명                                                         |
| ----------- | ------------------------------------------------------------ |
| CreateStack | 스택을 생성하는 연산 size 필요                               |
| IsEmpty     | 스택이 현재 비어있는지 확인 , T/F 리턴                       |
| IsFull      | 스택이 꽉 차있는지 확인, T/F 리턴                            |
| Push        | 저장소에 자료 저장                                           |
| Pop         | 저장소에서 자료 꺼냄. 꺼낸 자료는 삽입한 자료의 역순으로 꺼낸다. |
| Peek        | 스택의 top에 있는 값을 반환하는 연산 (top인덱스의 값)        |



2.  스택의 데이터 구조 

| 구조  | 설명                                                         |
| ----- | ------------------------------------------------------------ |
| top   | 스택의 가장 위에 있는 **위치** 저장하고 있는 데이터 (인덱스 위치) |
| size  | 스택 크기 저장하고 있는 데이터                               |
| items | 스택에 담길 데이터를 저장할 데이터 구조                      |



### 4. 스택의 구현

1. 스택의 push 알고리즘
   - append 메소드를 통해 리스트의 마지막에 데이터를 삽입

```python
def push(item):
    s.append(item)
```



2. 스택의 pop 알고리즘

```python
def pop():
    if len(s) == 0:
        # underflow 더 이상 꺼낼 것이 없는 상황 !! 
        return
    else:
        return s.pop(-1) #가장 마지막에 있는 애 꺼내서 돌려줘 .. 
```



- append, pop은 느리다!  대신 사용할 수 있는 방법 

```python
def push(item, size):
    global top
    top += 1
    # top이 사이즈 넘어가면 overflow
    if top == size:
        print('overflow!') # stack 크기가 너무 작거나 push를 너무 많이 함 / 디버깅용
    # 아니라면 저장 
    else:
        stack[top] = item
        
# 직접 스택 만들기
size = 10
stack = [0] * size
top = -1 


# 직접 구현도 가능
push(10, size)
top += 1  # push가 필요한 부분에 top 증가시키고 변수값 그냥 풀어서 저장 
stack[top] = 20
```

```python
def pop():
    global top
    if top == -1:
        print('underflow')
        return 0
    else:
        top -= 1
        return stack[top+1]

print(pop())

if top > -1: #pop
    top -= 1 
    print(stack[top+1])
```





### 5. 스택 구현 고려 사항

- 1차원 배열을 사용해 구현할 경우, 구현이 용이하다는 장점이 있지만 스택의 크기를 변경하기가 어렵다는 단점! 
- 동적 연결리스트 이용한 구현 : 저장소를 동적으로 할당해 스택을 구현하는 방법
  - 구현이 복잡하지만 메모리를 효율적으로 사용할 수 있다는 장점! 



### 6. 스택의 응용

#### 1. 괄호검사

- 괄호의 종류 
  - {, } [, ] (, )
- 조건 :
  1. 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야한다.
  2. 같은 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야한다.
  3. 괄호 사이에는 포함 관계만 존재

- 스택을 이용한 괄호 검사 
  - 왼쪽 괄호 만나면 스택에 삽입 
  - 오른쪽 괄호 만나면 스택에서 top 삭제 
  - 오른쪽 괄호와 짝이 맞는지 검사 
- 스택이 비어있으면 1,2 에 위배 / 괄호의 짝이 맞지 않으면 3에 위배 / 마지막 괄호 조사했는데 스택에 남아있으면 1에 위배



#### 2. function call

- 프로그램에서의 함수 호출과 복귀에 따른 수행 순서를 관리 
  - 가장 마지막에 호출된 함수가 가장 먼저 실행 완료하고 복귀 (후입선출 구조) / 후입선출 구조의 스택 이용해 수행순서 관리
  - 함수 실행이 끝나면 시스템 스택의 top원소 (스택 프레임 ..)
  - 뭐라는지 모르겠어요



#### 3. 재귀호출





### Memoization

- 메모이제이션 



```python
# memo를 위한 배열을 할당하고 모두 0으로 초기화 한다
# memo[0]을 0으로 memo[1] 은 1로 초기화 한다

def fibo1(n):
    global memo
    if n >= 2 and len(memo) <= n:
        memo.append(fibo1(n-1) + fibo1(n-2))
    return memo[n]

memo = [0, 1]
```



### DP(Dynamic Programming)

동적 계획 알고리즘.

최적화 문제를 해결하는 알고리즘 (가장 좋은 해답을 찾는 것)

- 먼저 입력 크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용해 보다 큰 크기의 부분 문제 해결
- 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘 



-  피보나치 수 DP 적용
  1. 문제를 부분 문제로 분할 
  2. 가장 작은 부분 문제부터 해를 구한다
  3. 결과를 테이블에 저장하고, 테이블에 저장된 부분 문제의 해를 이용해 상위 문제 해 구하기 



### DFS 깊이 우선  탐색

비선형구조인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요

- 두 가지 방법
  - 깊이 우선 탐색 (Depth First Search, DFS)
  - 너비 우선 탐색 (Breadth First Search, BFS)